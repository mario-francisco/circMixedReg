% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/kernels_weights.R
\name{kernel_weights}
\alias{kernel_weights}
\title{Compute product kernel weights for mixed predictors}
\usage{
kernel_weights(
  x0,
  X,
  z0,
  Z,
  h,
  lambda,
  kernel_continuous,
  kernel_categorical,
  levels_list = NULL
)
}
\arguments{
\item{x0}{Numeric vector of length \eqn{k}, containing the continuous predictors at the target point.}

\item{X}{Numeric matrix of size \eqn{n \times k}, where each row corresponds to a sample of continuous predictors.}

\item{z0}{Vector of length \eqn{p}, containing the categorical predictors at the target point.}

\item{Z}{Data frame or matrix of size \eqn{n \times p}, containing the categorical predictors for each sample.}

\item{h}{Numeric vector of length \eqn{k}, with bandwidths for continuous variables.}

\item{lambda}{Numeric vector of length \eqn{p}, with smoothing parameters for categorical variables.}

\item{kernel_continuous}{Univariate kernel function to be applied to each continuous variable (e.g., \code{dnorm}).}

\item{kernel_categorical}{Kernel function for categorical variables (e.g., \code{aitchison_aitken_kernel} or \code{ordinal_kernel}).}

\item{levels_list}{Optional list of levels for each categorical variable; required if using ordinal kernels.}
}
\value{
A numeric vector of length \code{n} with the normalized kernel weights.
}
\description{
Computes normalized product-kernel weights for a given target point
\eqn{(x_0, z_0)} using both continuous and categorical predictors.
Continuous predictors are smoothed using a multivariate product of
univariate kernel functions; categorical predictors use separate kernel
functions that may account for nominal or ordinal structure.
}
\details{
This version handles unmatched levels gracefully when using ordinal or nominal kernels,
and returns uniform weights if all computed weights are zero (to avoid division by zero).
}
\examples{
# Simulate example data
set.seed(123)
X <- matrix(runif(20), ncol = 1)
Z <- data.frame(group = sample(c("Low", "Medium", "High"), 20, replace = TRUE))
x0 <- 0.5
z0 <- "Medium"
h <- 0.1
lambda <- 0.3

# Define Gaussian kernel
gaussian_kernel <- function(u) exp(-0.5 * u^2) / sqrt(2 * pi)

# Define ordinal kernel
ordinal_kernel <- function(z, zi, lambda, levels) {
  z <- as.character(z)
  zi <- as.character(zi)
  d <- abs(match(z, levels) - match(zi, levels))
  return((1 - lambda)^d)
}

# Specify level ordering for ordinal kernel
levels_list <- list(c("Low", "Medium", "High"))

# Compute weights
kernel_weights(
  x0 = x0, X = X,
  z0 = z0, Z = Z,
  h = h, lambda = lambda,
  kernel_continuous = gaussian_kernel,
  kernel_categorical = ordinal_kernel,
  levels_list = levels_list
)

}
