% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/compute_CMASE_obs_by_group.R
\name{compute_CMASE_obs_by_group}
\alias{compute_CMASE_obs_by_group}
\title{Compute CMASE_obs by Group}
\usage{
compute_CMASE_obs_by_group(theta, x, z, fit_fun, condition_levels)
}
\arguments{
\item{theta}{Vector of observed circular responses (in radians). Can be numeric or of class \code{circular}.}

\item{x}{Matrix or data frame of continuous predictors (each row = one observation).}

\item{z}{Vector or factor of categorical predictor used to define the groups.}

\item{fit_fun}{A user-defined function that takes \code{x} and \code{z} as inputs and returns predicted values.}

\item{condition_levels}{Character vector with the levels of \code{z} to evaluate.}
}
\value{
A named numeric vector of CMASE_obs values, one for each group in \code{condition_levels}.
}
\description{
Computes the observational Circular Mean Average Squared Error (CMASE_obs) separately
for each level of a categorical grouping variable.
}
\details{
This function is useful to evaluate the performance of a circular regression model
across different subgroups (e.g., sensory conditions or experimental treatments).
}
\examples{
# Simulated example
set.seed(123)
n <- 60
x <- matrix(runif(n), ncol = 1)
z <- factor(rep(c("A", "B", "C"), each = 20))
mu_fun <- function(x, z) {
  if (z == "A") return(pi * x)
  if (z == "B") return(pi / 2 * x + pi / 4)
  return(pi * (1 - x))
}
theta <- sapply(1:n, function(i) (mu_fun(x[i], z[i]) + circular::rvonmises(1, 0, 3)) \%\% (2 * pi))
fit_fun <- function(xnew, znew) sapply(1:nrow(xnew), function(i) mu_fun(xnew[i], znew[i]))
compute_CMASE_obs_by_group(theta, x, z, fit_fun, condition_levels = c("A", "B", "C"))

}
