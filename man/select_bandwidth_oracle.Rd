% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/select_bandwidth_oracle.R
\name{select_bandwidth_oracle}
\alias{select_bandwidth_oracle}
\title{Oracle Bandwidth Selector for Circular Regression}
\usage{
select_bandwidth_oracle(
  x_grid,
  m_true,
  X,
  Z,
  theta,
  h_grid = NULL,
  lambda_grid = NULL,
  kernel_continuous = gaussian_kernel,
  kernel_categorical = aitchison_aitken_kernel,
  kernel_levels = NULL,
  estimator = "NW",
  B = 1
)
}
\arguments{
\item{x_grid}{Matrix or data frame of evaluation points (n_eval × k).}

\item{m_true}{Vector of true regression function values at \code{x_grid}.}

\item{X}{Matrix of continuous predictors used in estimation (n × k).}

\item{Z}{Data frame or matrix of categorical predictors (n × p). Can be NULL.}

\item{theta}{Vector of circular responses (in radians).}

\item{h_grid}{Optional list of candidate bandwidths for continuous variables. If NULL, a default grid is used.}

\item{lambda_grid}{Optional list of candidate smoothing parameters for categorical variables. If NULL, a default grid is used.}

\item{kernel_continuous}{Kernel function for continuous predictors.}

\item{kernel_categorical}{Kernel function for categorical predictors.}

\item{kernel_levels}{Optional list of level vectors (only needed for kernels like ordinal).}

\item{estimator}{Character string: either \code{"NW"} (default) or \code{"LL"}.}

\item{B}{Number of Monte Carlo replicates for CMISE estimation. Default is 1.}
}
\value{
A list with:
\describe{
\item{h_oracle}{Optimal bandwidths for continuous variables.}
\item{lambda_oracle}{Optimal smoothing parameters for categorical variables.}
\item{cmise_oracle}{Minimum estimated CMISE over the grid.}
}
}
\description{
Selects the optimal bandwidths (for continuous and categorical predictors)
by minimizing the true Circular Mean Integrated Squared Error (CMISE)
using a known regression function. Useful for simulation benchmarking.
}
\details{
Supports both Nadaraya-Watson ("NW") and local linear ("LL") estimators.
}
\examples{
set.seed(123)
n <- 30
x <- runif(n)
z <- sample(c("A", "B", "C"), n, replace = TRUE)
f_true <- function(x, z) {
  if (z == "A") return(pi * x)
  if (z == "B") return(pi / 2 * x + pi / 4)
  return(pi * (1 - x))
}
theta <- sapply(1:n, function(i) (f_true(x[i], z[i]) + circular::rvonmises(1, 0, 5)) \%\% (2 * pi))

data <- data.frame(x = x, z = z, theta = theta)
x_grid <- matrix(seq(0, 1, length.out = 25), ncol = 1)
m_true <- sapply(x_grid, function(xi) f_true(xi, "B"))  # Fix z = "B"

result <- select_bandwidth_oracle(
  x_grid = x_grid,
  m_true = m_true,
  X = as.matrix(data$x),
  Z = data["z"],
  theta = data$theta,
  estimator = "NW",
  kernel_continuous = gaussian_kernel,
  kernel_categorical = aitchison_aitken_kernel,
  kernel_levels = list(z = c("A", "B", "C")),
  B = 1
)

result$h_oracle
result$lambda_oracle
result$cmise_oracle

}
